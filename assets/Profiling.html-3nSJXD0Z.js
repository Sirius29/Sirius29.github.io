import{_ as i,c as l,o as e,b as a}from"./app-C9Xy_pz9.js";const o={},t=a('<h3 id="性能分析" tabindex="-1"><a class="header-anchor" href="#性能分析"><span>性能分析</span></a></h3><ul><li>Trace 跟踪系统调用</li><li>PMC Performance Monitoring Counters <ul><li>Count - 观察特定指标</li><li>Sample - 查找热点 <ul><li>调用栈</li><li>火焰图</li></ul></li></ul></li><li>编译器优化报告 <ul><li>PGO</li></ul></li><li>分析方法 <ul><li>Roofline Model <ul><li>程序性能受到硬件两个主要限制：peak compute performance，FLOPS 和 peak memory bandwidth，GB/s</li><li>计算强度 Arithmetic Intensity 为两者比值，计算访存比 计算强度低，提升访存速度；计算强度高，向量化、多线程</li></ul></li><li>Top-Down Microarchitecture Analysis Methodology（TMA）</li></ul></li><li>Linux Perf <ul><li>perf stat --topdown -a testset -c 0 ./bin 被内存限制，查看cache的缓存数量有没有下降 受限于一个内存层次的带宽，计算实际带宽是不是达到了峰值带宽</li></ul></li></ul><h3 id="top-down-microarchitecture-analysis-method-tma" tabindex="-1"><a class="header-anchor" href="#top-down-microarchitecture-analysis-method-tma"><span>Top-Down Microarchitecture Analysis Method（TMA）</span></a></h3><h4 id="cpu-back-end-optimization" tabindex="-1"><a class="header-anchor" href="#cpu-back-end-optimization"><span>CPU Back-End Optimization</span></a></h4><ul><li>Memory Bound <ul><li>Cache Friendly Data <ul><li>访存顺序 - 行主序、列主序</li><li>选择合适的容器 - 小对象直接存储，大对象可以存储指针，指针属于间接访存需要跳转</li><li>数据打包 - 位域，提升带宽利用率</li><li>数据对齐 - 避免一份数据在两个 cache line 中，但可能降低内存利用率</li><li>使用更高效的 malloc - 如 jemalloc、tcmalloc</li><li>调整访存以匹配内存结构 - 如矩阵乘中的分块</li></ul></li><li>Memory Prefetch <ul><li>软件预取 - 手动进行内存预取，适用于特定平台，不可移植，增加前端压力，可能会降低性能</li><li>硬件预取 - 硬件根据内存访问规律，自动将可能访问的内存搬运至 cache</li></ul></li><li>Reduce DTLB Miss <ul><li>使用更大的页面</li></ul></li></ul></li><li>Core Bound <ul><li>函数内联 - 避免函数调用开销</li><li>循环优化 <ul><li>提取公共部分至循环外侧</li><li>循环展开 - 降低循环次数，增加循环内计算强度，循环内流水线更饱满</li><li>避免循环内分支判断</li><li>调整循环 index / 分块 - 使循环内访存 cache friendly</li><li>循环的拆分和融合</li></ul></li><li>向量化 SIMD</li><li>Intrinsics - 依赖编译器优化代码，多会产生次优代码，如访存使默认非对齐访问</li></ul></li></ul><h4 id="cpu-front-end-optomization" tabindex="-1"><a class="header-anchor" href="#cpu-front-end-optomization"><span>CPU Front-End Optomization</span></a></h4><ul><li>优化机器码布局 频繁执行的代码（hot code）放一起，不常执行的代码（cold code）放一起 <ul><li>cold code 避免内联</li><li>Function splitting - hot code 和 cold code 分割</li><li>Function group - cold code 封装成函数，保留调用</li></ul></li><li>Reduce ITLB Misses 使用大页面</li></ul><h4 id="bad-speculation" tabindex="-1"><a class="header-anchor" href="#bad-speculation"><span>Bad Speculation</span></a></h4><ul><li>将分支判断转换为查表</li><li>用三元运算符替换分支判断 - 实际情况具体分析</li></ul><h4 id="other" tabindex="-1"><a class="header-anchor" href="#other"><span>Other</span></a></h4><ul><li>输入输出优化 - 文件读取，用 mmap 替代 fstream</li><li>元编译 - 编译时间换 runtime 时间</li><li>Cache Warm</li><li>特殊浮点运算 - 部分特殊浮点运算非常耗时</li></ul>',11),n=[t];function c(r,s){return e(),l("div",null,n)}const u=i(o,[["render",c],["__file","Profiling.html.vue"]]),h=JSON.parse('{"path":"/program/Profiling.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"性能分析","slug":"性能分析","link":"#性能分析","children":[]},{"level":3,"title":"Top-Down Microarchitecture Analysis Method（TMA）","slug":"top-down-microarchitecture-analysis-method-tma","link":"#top-down-microarchitecture-analysis-method-tma","children":[]}],"git":{"updatedTime":1723385789000,"contributors":[{"name":"Sirius29","email":"422058530@qq.com","commits":1}]},"filePathRelative":"program/Profiling.md"}');export{u as comp,h as data};
